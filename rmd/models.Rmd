# Description of models

In the following section, we will motivate and define mathematically four Generalised Linear Models (GLMs) implemented in Stan and using BRMS in two cases.

```{r, message=FALSE, warning=FALSE}
# install libraries
library(survival)
library(tidyverse)
library(rstan)
library(brms)
library(bayesplot)
library(loo)
library(reshape2)
library(ggplot2)
library(data.table)
# set number of cores
options(mc.cores = parallel::detectCores())
# read lung cancer data from `survival` library
data("cancer", package = "survival")
# set random seed for reproducibility
set.seed(300614)
```

## Weibull without censored data

Let $y \sim \text{Weibull}(\alpha, \sigma)$, so that
$$
\text{Weibull}(y|\alpha,\sigma) =
\frac{\alpha}{\sigma} \, \left( \frac{y}{\sigma} \right)^{\alpha - 1}
\, \exp \! \left( \! - \left( \frac{y}{\sigma} \right)^{\alpha}
\right),
$$
for $y \in [0,\infty), \alpha \in \mathbb{R}^+,$ and $\sigma \in \mathbb{R}^+$. 

### Motivating the distribution

The Weibull distribution is often used as a more flexible and complex alternative to the semi-parametric proportional hazard Cox model for modelling time to failure events, since the hazard rate is not taken to be constant with time.

### The Weibull distribution as a member of the exponential family

Now take $\alpha$ fixed and finite, then it can be shown that this distribution belongs to the exponential family since we can write it's probability density function
$$
\text{Weibull}(y|\sigma) ={\alpha y^{\alpha -1}}\exp(-y^{\alpha}\sigma^{-\alpha}-\alpha\log\sigma),
$$
with
\begin{align*}
b(y)&={\alpha y^{\alpha -1}} \\
\eta&=\sigma^{-\alpha}\\
T(y)&=-y^{\alpha} \\
a(\eta)&=\alpha\log\sigma.
\end{align*}

### Defining the link function

Looking at our sufficient statistic $\eta=\sigma^{-\alpha}$, it can be shown that
$$
\sigma=\exp{({\frac{\log\eta}{-\alpha}})}
$$
where we construct $\eta = \exp(\boldsymbol X\beta)$ so that $\eta$ is strictly positive. Thus we choose a log link function for our GLM such that
$$
\sigma = \exp(-\frac{\boldsymbol X\beta}{\alpha}).
$$

### Priors

In our Stan model, we will enforce two priors over each of the regressors in the linear model, and the shape parameter of our resulting Weibull distribution. Mathematically, where we have $N$ data points and $M$ covariates, the model is defined as
\begin{align*}
y_i &\sim \text{Weibull}(\sigma, \alpha)\,,\quad i = 1,\dots,N,\\
\alpha &\sim \text{Half-Cauchy}(5),\\
\sigma &= \exp\left ( -\frac{\boldsymbol X \beta}{\alpha}\right ),\\
\beta_k \sim& N(0, 10)\,,\quad k=1,\dots,M.\\
\end{align*}
The choice of a Half-Cauchy prior is motivated in @taumain, so that inferences are sensitive to the choice of weakly-informative priors. Note that this is a specific case of the of the conditionally-conjugate folded-noncentral-t family of prior distributions. In this pooled model, we model these parameters the same across all institutions. Intuitively, this means that we expect the hazard to be equivalent regardless of which institution a patient is in. This is seen visually below in Figure \ref{}.

### Implemented in Stan

Below, we fit the model in Stan and output the Stan code for the reader.

```{r weibull, warning=FALSE, message=FALSE}
# build dataset from only those non-censored data points
uncensored_data <- cancer %>%
  filter(status == 2) %>%
  filter(inst %in% c(1, 12, 13, 3, 11, 22, 16)) %>%
  drop_na()
# identify covariate labels and build design matrix
cov_labels <- uncensored_data %>%
  dplyr::select(-status,-time,-inst) %>%
  colnames()
# build design matrix
X <- as.matrix(uncensored_data[cov_labels])
# print(dim(X))
# [1] 120   7
y <- uncensored_data$time
# build data list for Stan model
weibull_data = list(
  y = y, X = X, N = length(y), M = ncol(X)
)
# compile and run seperate model
wm <- rstan::stan_model(file = "../stan/weibull_survival.stan")
# print out Stan code
print(wm)
# learn the model parameters
weibull_model <- rstan::sampling(
  wm,
  iter = 10000,
  data = weibull_data,
  algorithm = "NUTS"
)
```

## Weibull with censored data

The density function for Weibull distributed survival times is given as

$$
{p(t_{i}|\alpha,\lambda_{i}) = \alpha t_{i}^{\alpha-1}\exp{(\lambda_{i}-\exp{\lambda_{i}}t_{i}^{\alpha})}},
$$

and can be rewritten as

$$
{p(t_{i}|\alpha,\gamma_{i}) = \exp{\bigg(-\bigg(\frac{t_{i}}{\gamma_{i}}\bigg)^{\alpha}\bigg)}\frac{\alpha}{\gamma_{i}}\bigg(\frac{t_{i}}{\gamma_{i}}\bigg)^{\alpha-1}},
$$
where $\alpha$ is the shape parameter, and $\gamma$ the scale. We move on to define a new variable $\lambda$ is created, defined in relation to $\gamma$ as

$$
{\lambda=-\alpha \log{\gamma}}.
$$

The survival function, showing the probability that the death will be after a certain time t, is then

$$
{S(t_{i}|\alpha,\lambda_{i})=\exp(-\exp(\lambda_{i})t_{i}^{\alpha})}.
$$

The likelihood of $\alpha$ and $\lambda$ follows the equation below, with $v_{i}$ an indicator showing 0 if the data are censored and 1 if not,

$$
{L(\alpha,\lambda|t)=\prod\limits_{i = 1}^n p(t_{i}|\alpha,\lambda_{i})^{v_{i}} S(t_{i}|\alpha,\lambda_{i})^{1-v_{i}}}=
\prod\limits_{i = 1}^n (\alpha t_{i}^{\alpha-1}exp(\lambda_{i}))^{v_{i}}(exp(-exp(\lambda_{i})t_{i}^{\alpha})).
$$

If $\lambda=X\beta$, than log-likelihood function can be expressed as,

$$
l(\alpha,\beta|t,x)=\sum\limits_{i = 1}^nv_{i}(\log(\alpha)+(\alpha-1)log(t_{i})+X_{i}\beta)-\exp(X_{i}\beta)t_{i}^{\alpha}.
$$
If the data are censored, log-likelihood consists only of the logarithm of the survival function. In Stan this can be expressed with `weibull_lccdf()` function, corresponding to the log of the Weibull complementary cumulative distribution function of $y$ given shape $\alpha$ and scale $\sigma$, and it is exactly the logarithm of survival function. For clarity, complementary cumulative distribution function is
$$
\bar{F}_{X}(x)=P(X>x)=1-F_{X}(x),
$$
where $F_{X}(x)$ is the cumulative distribution function.

### Priors

Weakly-informative priors for parameters are used. There are 7 covariates in the model, for each regressor $\beta$ can take positive and negative values, however, these values are not likely to be very large. For them, normal distribution $N(0,10)$ can be used.  Also, the prior has to be made for the shape parameter, $Gamma(1,1)$ is a variant, as the majority of the variance is not too close to zero, it has rather long tail, but which is not too heavy. Even we are not experts-oncologists, we know that typically person's with advanced lung cancer is a little bit lower than a year, some patients live even for three years. The chosen prior is suitable, as it allows to produce survival time values, which are not too strict and at the same time really unlike to be larger than 5 years, for example.

$$
\beta \sim N(0,10)
$$

$$
\alpha \sim \text{Gamma}(1,1)
$$
Chosen priors do not contribute strongly to the posterior, so the data can "speak for itself".

### Implemented in Stan

Data preparation
```{r, warning=FALSE, message=FALSE}
# read lung cancer data from "survival' library
data("cancer", package = "survival")

# omittimg NAs
data = cancer %>% 
  filter(inst %in% c(1, 12, 13, 3, 11, 22, 16)) %>%
  na.omit()

# Censoring status is transformed to the column with 0-censored, 1-observed.
# The continuous variables are centered.
X=data
X$status[X$status==1] = 0
X$status[X$status==2] = 1
#X$male = ifelse(X$sex==1,1,0)
#X$female = ifelse(X$sex==2,1,0)
X$age=X$age-mean(X$age)
X$meal.cal=X$meal.cal-mean(X$meal.cal)
X$wt.loss=X$wt.loss-mean(X$wt.loss)

Xcens=X[X$status==0,]
Xcens = Xcens[-c(1,2,3)]
ycens=X$time[X$status==0]

Xobs=X[X$status==1,]
Xobs = as.matrix(Xobs[-c(1,2,3)])
yobs=X$time[X$status==1]
```

Building data list for Stan model
```{r, warning=FALSE, message=FALSE, comment=FALSE}
data_model = list(
  yobs = yobs,
  Xobs = Xobs,
  N = nrow(Xobs),
  M = ncol(Xobs),
  ycen = ycens,
  Xcen = Xcens,
  Ncen = nrow(Xcens)
)
```

Running model
```{r censored, warning=FALSE, message=FALSE}
# compile and run censored model
cwm = rstan::stan_model(file = "../stan/weibull_censored.stan")
# print out Stan code
print(cwm)
# learn the model with parameters 4 chains, 10000 iterations for each, 5000 iterations for warm-up
weibull_cens = rstan::sampling(cwm, data = data_model, iter = 10000)
```


## Hierarchical Weibull without censored data

Here we implement a model with some global shape parameter to be learned, but independent regressor parameters for each institution. Once more, we ignore the censored data. By virtue of this, we need not worry about complex distribution functions, but do sacrifice the number of data points we can learn from for each institution. We now consider our model in terms of the same $N$ data points and $M$ regressors, but we will estimate our covariate's weight according to the institution, of which we have $J$ in total. Thus our model is defined as
\begin{align*}
y_{ij} &\sim \text{Weibull}(\sigma_j, \alpha)\,,\quad i = 1,\dots,N,\,j= 1,\dots,J\\
\alpha &\sim \text{Half-Cauchy}(5),\\
\sigma &\propto \boldsymbol X \beta,\\
\beta_{kj} \sim& N(0, 1)\,,\quad k=1,\dots,M,\,j= 1,\dots,J.\\
\end{align*}
This is seen visually below in Figure \ref{}.

### Defining the link function

### Priors

The same priors are used for the hierarchical model as the pooled model

### Implemented in Stan

```{r hier_weibull, warning=FALSE, message=FALSE}
# build dataset from only those non-censored data points
uncensored_data <- cancer %>%
  filter(status == 2) %>%
  filter(inst %in% c(1, 12, 13, 3, 11, 22, 16)) %>%
  drop_na()
# identify covariate labels and build design matrix
cov_labels <- uncensored_data %>%
  dplyr::select(-status,-time,-inst) %>%
  colnames()
# build design matrix
X <- as.matrix(uncensored_data[cov_labels])
# observed survival times
y <- uncensored_data$time
# institution labels
ll <- as.numeric(as.factor(uncensored_data$inst))
# build some hierarchical data for Stan
hier_data = list(
  y = y,
  X = X,
  ll = ll,
  N = length(y),
  M = ncol(X),
  J = length(unique(ll))
)
# compile and run seperate model
whm <- rstan::stan_model(file = "../stan/weibull_hier.stan")
# print out Stan code
print(whm)
# learn the model parameters
weibull_hier <- rstan::sampling(whm, data = hier_data, iter = 7000)
```

In certain situations, the group-level parameters do not constrain the hierarchical distribution closely enough. This can occur when we either have many groups or high variance between the groups. In order to make hierarchical model sampling more efficient and to improve effective sample size metrics, we can employ a so-called _non-centered parameterisation_, where we replace the parameterisation of 
```
parameters {
  // GLM parameters
  matrix[M, J] beta;            // regressors weights for different institutions
  real<lower=0> alpha;          // shape parameter
  ...
}
model {
  // hyperpriors
  mu_beta ~ std_normal();
  sigma_beta ~ gamma(1, 1);
  // prior over regressor and shape parameters
  for (j in 1:J) {
    beta[, j] ~ normal(mu_beta, sigma_beta);
  }
  ...
```
to
```
parameters {
  // GLM parameters
  matrix[M, J] beta_unif;       // non-centered parameterisation regressors
  real<lower=0> alpha;          // shape parameter
  ...
}
transformed parameters {
  matrix[M, J] beta;            // regressors weights for different institutions
  // implies: beta ~ normal(mu_beta, sigma_beta)
  for (j in 1:J) {
    beta[, j] = mu_beta + sigma_beta * beta_unif[, j];
  }
  ...
}
model {
  // hyperpriors
  mu_beta ~ std_normal();
  sigma_beta ~ gamma(1, 1);
  // prior over regressor and shape parameters (non-centered parameterisation)
  for (j in 1:J) {
    beta_unif[, j] ~ std_normal();
  }
  ...
```
so that our `beta`, `mu_beta` and `sigma_beta` are less correlated with our posterior, and thus increasing the effective sample size, as is shown in @betancourt2013hamiltonian. Below, we fit such a non-centered parameterised model and compare the effective sample sizes of the two parameterisations to shown this to be the case.

```{r noncentered, warning=FALSE, message=FALSE}
# build non-centered parameterisation model
whmnc <- rstan::stan_model(file = "../stan/weibull_hier_noncentered.stan")
weibull_hier_nc <- rstan::sampling(whmnc, data = hier_data, iter = 7000)

neff_cp <- neff_ratio(weibull_hier)
neff_ncp <- neff_ratio(weibull_hier_nc)
bayesplot::bayesplot_grid(
  bayesplot::mcmc_neff(neff_cp), bayesplot::mcmc_neff(neff_ncp)
)

bayesplot::bayesplot_grid(bayesplot::mcmc_rhat(rhat = rhat(weibull_hier)),
                          bayesplot::mcmc_rhat(rhat = rhat(weibull_hier_nc)))
```

